\section{Задача о поиске паттерна на помеченном графе}

\subsection{Постановка задачи}
\par Пусть $L$ -- непустое конечное множество \textbf{(множество меток)}. Пусть $G(V, E)$, $G'(V', E')$ -- ориентированные связные графы. Будем называть граф $G$ архивным графом, граф $G'$ -- графом-паттерном, или шаблонным графом.

Введём отображения $l : V \to L$, $l' : V' \to L$, сопоставляющие вершинам архивного и шаблонного графов соответствующие метки. При этом мы требуем, чтобы введённые на шаблонном графе метки были уникальны, т.е. отображение $l'$ -- инъективно.

\begin{defn}
	Совпадением на графе $G$ будем называть частичный подграф $\widehat{G}(\widehat{V}, \widehat{E})$ графа $G$ такой, что:
	\begin{enumerate}
		\item Существует биективное отображение $m_{\widehat{G}}: V' \to \widehat{V}$.
		\item $\forall v' \in V': l'(v') = l(m_{\widehat{G}}(v'))$
		\item $\forall (v^{\prime}_1, v^{\prime}_2) \in E': (m_{\widehat{G}}(v^{\prime}_1), m_{\widehat{G}}(v^{\prime}_2)) \in E$
	\end{enumerate}
\end{defn} 

Пусть для вершины $v \in V$ существует некоторое совпадение  $\widehat{G}(\widehat{V}, \widehat{E})$ на графе $G$ такое, что $v \in \widehat{V}$. Тогда вершину $v$ будем называть подходящей паттерну $G'$ по совпадению $\widehat{G}$, иначе -- неподходящей. В случае, если вершина $v$ подходит по совпадению $\widehat{G}$, вершину $m_{\widehat{G}}^{-1}(v) \in  V'$ назовём соответствующей данной вершине $v$. Заметим, что вершина $v$ может подходить паттерну по нескольким совпадениям, но в силу инъективности отображения $l'$ ей может соответствовать лишь одна вершина $v' \in  V'$.

Через $\widetilde{V} \subseteq V$ обозначим множество всех подходящих паттерну $G'$ вершин. Наша задача и будет состоять в отыскании этого подмножества. Опишем используемый нами алгоритм.

Пусть $T = \emptyset \cup \mathcal{C}_{V'}^1$ -- все 0-элементные и 1-элементные подмножества множества вершин графа-паттерна. Построим отображение $f_0 : V \to T$, заданное следующим:
\begin{equation}
v' \in f_0(v) \Leftrightarrow l(v) = l'(v').
\end{equation}

Нетрудно убедиться, что в силу инъективности отображения $l$, введённое отображение $f_0$ действительно имеет областью значений множество $T$.

Алгоритм будет строиться на изменении отображения $f_0$, поэтому для удобства нам потребуется ввести операцию над подобными отображениями. Пусть $f_1, f_2 : V \to 2^{V'}$. Обозначим $f_2 = Exclude(f_1, v_0 (\in V), v^{\prime}_0 (\in V'))$, если выполнено следующее:
\begin{enumerate}
	\item $\forall v \ne v_0 \in V: f_1(v) = f_2(v)$.
	\item $v^{\prime}_0 \notin f_2(v_0)$.
	\item $\{v^{\prime}_0\} \cup f_2(v_0) = f_1(v_0)$
\end{enumerate}

Ясно, что по отображению $f_1$ легко построить отображение $Exclude(f_1, v_0, v^{\prime}_0)$, просто исключая вершину $v^{\prime}_0$ из множества $f_1(v_0)$.

\subsection{Алгоритм исключения по локальным условиям}

Для начала дадим несколько определений.

\begin{defn}
	Пусть дан граф $G(V, E)$. Пусть $v \in V$. Тогда обозначим через $Adj(v)$ множество смежных с ней вершин: $Adj(v) = \{u \in V | \exists (v, u) \in E \}$. Если $\widetilde{V} \subset V$, то $Adj(\widetilde{V}) = \bigcup\limits_{\widetilde{v} \in \widetilde{V}} Adj(\widetilde{v})$. В частности, $Adj(\emptyset) = \emptyset$.
\end{defn} 

\begin{defn}
	Пусть $G(V, E)$, $G'(V', E')$ -- архивный и шаблонный графы соответственно. Пусть задано отображение $f : V \to T$, где множество $T$ определено выше. Путь также $v \in V$. Назовём предикатом локальных условий следующий предикат:
	\begin{equation}
		LCC(f, v) = \forall u' \in Adj(f(v)) \exists u \in Adj(v) : u' \in f(u).
	\end{equation} 
\end{defn} 

Ниже приведён алгоритм LCCE -- исключения по локальным условиям.
\begin{algorithm}[H]
	\Large
	\KwIn{графы $G(V, E)$, $G'(V', E')$, отображение $f_0 : V \to T$, число итераций $N$}
	\KwOut{измененённое отображение $f_N$}
	\Begin(LCCE){
		\For{$i = 1, 2, .., N$}{
			$f_i := f_{i-1}$
			\For{$v \in V$}
			{
				\If{$\neg LCC(f_i, v)$}
				{
					$f_i(v) := \emptyset$
				}
			}
		}
		\Return{$f_N$}
	}

	\caption{Алгоритм исключения по локальным условиям}
	\label{alg:LCCE}
\end{algorithm}

Данный алгоритм на каждой итерации <<прореживает>> отображение $f_0$, то есть всегда выполнено $\forall v \in V f_{i}(v) \subset f_{i-1}$. Такое прореживание исключает на каждой итерации $i$ из списка кандидатов те вершины $v$, для которых оказывается, что хотя бы для одной из вершин $u' \in Adj(f_i(v))$ не существует такой вершины $u \in Adj(v)$, что $f(u) = u'$. Заметим, что схожая идея используется в различных классических алгоритмах теории графов, например, в алгоритме Беллмана-Форда. Следуя той же схеме доказательства, которая используется, например, при обосновании того факта, что алгоритм Беллмана-Форда находит на бесконтурном графе кратчайшие пути за количество итераций, равное его диаметру, мы придём к тому, что для бесконтурного графа $G'$ алгоритм $LCCE$ отработает <<до конца>> за $diam(G')$ итераций. Говоря <<до конца>>, мы имеем в виду, во-первых, что последующие итерации алгоритма более не удалят из отображения $f$ ни одного кандидата, а во-вторых, все вершины $v \in V$, для которых $f(v)$ не пусто, будут действительно вершинами некого графа-совпадения, ведь для каждой вершины $u = f(v)$, каждый начинающийся в ней путь (а в силу бесконтурности графа, этот путь конечный, и его длина не превышает диаметра графа) имеет некий соотносящийся с этим путём путь в графе $G$, начинающийся в вершине $v$.

Для графов-паттернов с циклами всё обстоит несколько сложнее. На таких графах существуют бесконечные пути, а потому для них применение приведённого выше алгоритма со сколь угодно большим числом итераций не гарантирует того, что оставшиеся вершины-кандидаты будут в действительности вершинами некоторого графа-совпадения. Поэтому для графов с циклами мы будем применять, помимо алгоритма $LCCE$, ещё и алгоритм, описанный ниже.

\subsection{Алгоритм проверки контуров}

Пусть $\mathcal{K}_0$ -- это набор контуров графа $G'$. В этот набор достаточно включить все простые контуры этого графа. 
Пусть $\mathcal{C}_0 \in \mathcal{K}_0$ -- какой-то из рассматриваемых контуров. Тогда если $\mathcal{C}_0 = ((v_0', v_1'), ..., (v_{r-1}^{\prime}, v_0^{\prime}))$ и $v_0^{\prime} \in f(v_0)$, то алгоритм $CCE$, приведённый ниже, исключит вершину $v_0^{\prime}$ из множества $f(v_0)$, если окажется, что нет контура, начинающегося в вершине $v_0$ и соответствующего (в смысле отображения $f$) контуру $\mathcal{C}_0$.

\begin{algorithm}[H]
	\Large
	\KwIn{графы $G(V, E)$, $G'(V', E')$, отображение $f_0 : V \to T$}
	\KwOut{измененённое отображение $f_N$}
	\Begin(CCE){
		\ForEach{$\mathcal{C}_0 \in \mathcal{K}_0$}{
				Пусть $(v_0^{\prime}, v_1^{\prime})$ -- первая дуга конутра $\mathcal{C}_0$.
			
			 	$\mathcal{A} := \emptyset$
			 	
			 	$\mathcal{A}_0 := \emptyset$
			 
			 	\ForAll{$v_0: f(v_0) \ne \emptyset$}{
			 		$\mathcal{A}_0 := \mathcal{A}_0 \cup \{v_0\}$
			 		
			 		$\mathcal{A} := \mathcal{A} \cup \{(v_0, v_0, 0)\}$
		 		}
	 		
	 			\For{$s = 1, 2, ..., |\mathcal{C}_0|$}{
		 			Пусть $(q_0, q_1)$ -- $s$-я дуга конутра $\mathcal{C}_0$.
		 			
	 				$\mathcal{B} := \emptyset$
	 				
	 				\ForEach{$(v, v_0, s - 1) \in \mathcal{A}$}{
	 					\For{$v^{\prime} \in Adj(v) $}{
	 						\If{$q_1 \in f(v^{\prime})$}{
	 							$\mathcal{B} := \mathcal{B} \cup \{(v^{\prime}, v_0, s)\}$
 							}
 						}
 					}
 				
	 				$\mathcal{A} := \mathcal{B}$
	 			}
	 			
	 			
	 			\ForEach{$v_0 \in \mathcal{A}$}{
	 				\If{$ (v_0, v_0, |\mathcal{C}_0|) \notin \mathcal{A} $}{
	 					$f(v_0) = \emptyset$
 					}
	 			}
		}
		\Return{$f_N$}
	}

	\caption{Алгоритм проверки контуров}
	\label{alg:CCE}
\end{algorithm}

Нахождение всех контуров графа и такой их обход -- задачи с очень высокой вычислительной сложностью, но на практически встречающихся графах, тем не менее, основная работа будет сделана алгоритмом $LCCE$. Впрочем, ничего страшного не произойдёт, если рассматриваться будут не все циклы -- можно попытаться выделить подграф совпадения и по неточному списку кандидатов. Здесь много зависит от конкретного вида графов и стоящей перед нами задачи.

Сами авторы статьи ожидают, что граф-паттерн будет содержать достаточно мало циклов, поэтому приводимая ими оценка $O(|\mathcal{K}_0|n_t(|V| + |E|))$, где $n_t = \max\limits_{\mathcal{C}_0 \in \mathcal{K}_0} n_{\mathcal{C}_0}$, где $n_{\mathcal{C}_0}$ -- это количество вершин в $V$, соответствующих контуру $\mathcal{C}_0$.

\subsection{Общий алгоритм исключения вершин-кандидатов}

Два вышеприведённых алгоритма объединяются в следующем цикле, который выполняется до тех пор, пока из отображения $f$ ещё удаляются какие-то вершины-кандидаты.

\begin{algorithm}
	\Large
	\KwIn{графы $G(V, E)$, $G'(V', E')$, отображение $f : V \to T$}
	\KwOut{измененённое отображение $f$}
	\Begin(Exclusion){
		\While{вершины-кандидаты продолжают удаляться из отображения $f$}{
			$LCCE(G, G', f)$
			$CCE(G, G', f)$
		}
		\Return{$f$}
	}

	\caption{Алгоритм исключения вершин-кандидатов}
	\label{alg:EE}
\end{algorithm}

Формируя начальное отображение $f$ исходя из совпадений по меткам архивного графа и графа-паттерна, мы передаём его алгоритму Exclusion и получаем на выходе новое, <<прореженное>> отображение, состоящее исключительно из истинных кандидатов.
