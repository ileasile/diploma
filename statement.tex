\section{Задача о поиске паттерна на помеченном графе}

\subsection{Постановка задачи}
\par Пусть $L$ -- непустое конечное множество \textbf{(множество меток)}. Пусть $G(V, E)$, $G'(V', E')$ -- ориентированные связные графы. Будем называть граф $G$ архивным графом, граф $G'$ -- графом-паттерном, или шаблонным графом.

Введём отображения $l : V \to L$, $l' : V' \to L$, сопоставляющие вершинам архивного и шаблонного графов соответствующие метки. При этом мы требуем, чтобы введённые на шаблонном графе метки были уникальны, т.е. отображение $l'$ -- инъективно.

\begin{defn}
	Совпадением на графе $G$ будем называть частичный подграф $\widehat{G}(\widehat{V}, \widehat{E})$ графа $G$ такой, что:
	\begin{enumerate}
		\item Существует биективное отображение $m_{\widehat{G}}: V' \to \widehat{V}$.
		\item $\forall v' \in V': l'(v') = l(m_{\widehat{G}}(v'))$
		\item $\forall (v^{\prime}_1, v^{\prime}_2) \in E': (m_{\widehat{G}}(v^{\prime}_1), m_{\widehat{G}}(v^{\prime}_2)) \in E$
	\end{enumerate}
\end{defn} 

Пусть для вершины $v \in V$ существует некоторое совпадение  $\widehat{G}(\widehat{V}, \widehat{E})$ на графе $G$ такое, что $v \in \widehat{V}$. Тогда вершину $v$ будем называть подходящей паттерну $G'$ по совпадению $\widehat{G}$, иначе -- неподходящей. В случае, если вершина $v$ подходит по совпадению $\widehat{G}$, вершину $m_{\widehat{G}}^{-1}(v) \in  V'$ назовём соответствующей данной вершине $v$. Заметим, что вершина $v$ может подходить паттерну по нескольким совпадениям, но в силу инъективности отображения $l'$ ей может соответствовать лишь одна вершина $v' \in  V'$.

Через $\widetilde{V} \subseteq V$ обозначим множество всех подходящих паттерну $G'$ вершин. Задача состоит в отыскании этого подмножества. Далее описан алгоритм исключения по локальным условиям, используемый для её решения.

\subsection{Алгоритм исключения по локальным условиям}

Пусть $T = \emptyset \cup \mathcal{C}_{V'}^1$ -- все 0-элементные и 1-элементные подмножества множества вершин графа-паттерна. Построим отображение $f_0 : V \to T$, заданное следующим:
\begin{equation}
v' \in f_0(v) \Leftrightarrow l(v) = l'(v').
\end{equation}

Нетрудно убедиться, что в силу инъективности отображения $l$, введённое отображение $f_0$ действительно имеет областью значений множество $T$.

Алгоритм исключения по локальным условиям будет строиться на изменении отображения $f_0$, поэтому для удобства нам потребуется ввести операцию над подобными отображениями. Пусть $f_1, f_2 : V \to 2^{V'}$. Обозначим $f_2 = Exclude(f_1, v_0 (\in V), v^{\prime}_0 (\in V'))$, если выполнено следующее:
\begin{enumerate}
	\item $\forall v \ne v_0 \in V: f_1(v) = f_2(v)$.
	\item $v^{\prime}_0 \notin f_2(v_0)$.
	\item $\{v^{\prime}_0\} \cup f_2(v_0) = f_1(v_0)$
\end{enumerate}

Ясно, что по отображению $f_1$ легко построить отображение $Exclude(f_1, v_0, v^{\prime}_0)$, просто исключая вершину $v^{\prime}_0$ из множества $f_1(v_0)$.

Прежде чем привести алгоритм, введём ещё несколько определений.

\begin{defn}
	Пусть дан граф $G(V, E)$. Если $\widetilde{V} \subset V$, то $\Gamma(\widetilde{V}) = \bigcup\limits_{\widetilde{v} \in \widetilde{V}} \Gamma(\widetilde{v})$. В частности, $\Gamma(\emptyset) = \emptyset$.
\end{defn} 

\begin{defn}
	Пусть $G(V, E)$, $G'(V', E')$ -- архивный и шаблонный графы соответственно. Пусть задано отображение $f : V \to T$, где множество $T$ определено выше. Путь также $v \in V$. Назовём предикатом локальных условий следующий предикат:
	\begin{equation}
		LCC(f, v) = \forall u' \in \Gamma(f(v)) \exists u \in \Gamma(v) : u' \in f(u).
	\end{equation} 
\end{defn} 

Ниже приведён алгоритм LCCE -- исключения по локальным условиям.
\begin{algorithm}[H]
	\Large
	\KwIn{графы $G(V, E)$, $G'(V', E')$, отображение $f_0 : V \to T$, число итераций $N$}
	\KwOut{измененённое отображение $f_K$}
	\Begin(LCCE){
		$K := 0$
		
		$F_0 := f_0$
		
		\For{$i = 1, 2, .., N$}{
			\For{$v \in V$}
			{
				\If{$\neg LCC(f_i, v)$}
				{	
					$S := K$
					
					\For{$v' \in f_S(v)$}{
						$f_{K+1} := Exclude(f_{K}, v, v')$
						
						$K := K + 1$
					}
				}
			}
		
			$F_i := f_K$
		}
		\Return{$f_N$}
	}

	\caption{Алгоритм исключения по локальным условиям}
	\label{alg:LCCE}
\end{algorithm}

Данный алгоритм принимает на вход отображение $f_0$, сопоставляющее вершинам графа их вершины-кандидаты в графе-паттерне. На каждой итерации цикла выполнено $\forall v \in V f_{i}(v) \subset f_{i-1}$. На каждой итерации $i$ из списка кандидатов исключаются те вершины $v$, для которых оказывается, что хотя бы для одной из вершин $u' \in \Gamma(f_i(v))$ не существует такой вершины $u \in \Gamma(v)$, что $f(u) = u'$. Схожая идея используется в различных классических алгоритмах теории графов, например, в алгоритме Беллмана-Форда \cite{bellmanford}. Следуя той же схеме доказательства, которая используется, например, при обосновании того факта, что алгоритм Беллмана-Форда находит на бесконтурном графе кратчайшие пути за количество итераций, равное диаметру графа, мы придём к тому, что для бесконтурного графа $G'$ алгоритм $LCCE$ отработает за $diam(G')$ итераций, после чего все вершины $v \in V$, для которых $f(v)$ не пусто, будут действительно вершинами некого графа-совпадения, ведь для каждой вершины $u = f(v)$, каждый начинающийся в ней путь (а в силу бесконтурности графа, этот путь конечный, и его длина не превышает диаметра графа) имеет некий соотносящийся с этим путём путь в графе $G$, начинающийся в вершине $v$. Для бесконтурного графа можно отдельно не вычислять его диаметр, просто прервав алгоритм после итерации $i$, для которой $F_i = F_{i-1}$.

Для графов-паттернов с контурами применение только этого алгоритма не даёт требуемого результата. На таких графах существуют бесконечные пути, а потому для них применение приведённого выше алгоритма со сколь угодно большим числом итераций не гарантирует того, что оставшиеся вершины-кандидаты будут в действительности вершинами некоторого графа-совпадения. Поэтому для графов с контурами мы будем применять, помимо алгоритма $LCCE$, ещё и алгоритм, описанный ниже.

\subsection{Алгоритм проверки контуров}

Пусть $\mathcal{K}_0$ -- это набор контуров графа $G'$. В этот набор достаточно включить все простые контуры этого графа. 
Пусть $\mathcal{C}_0 \in \mathcal{K}_0$ -- какой-то из рассматриваемых контуров. Тогда если $\mathcal{C}_0 = ((v_0', v_1'), ..., (v_{r-1}^{\prime}, v_0^{\prime}))$ и $v_0^{\prime} \in f(v_0)$, то алгоритм проверки контуров \ref{alg:CCE}, приведённый ниже, исключит вершину $v_0^{\prime}$ из множества $f(v_0)$, если окажется, что нет контура, начинающегося в вершине $v_0$ и соответствующего (в смысле отображения $f$) контуру $\mathcal{C}_0$.

\begin{algorithm}[H]
	\Large
	\KwIn{графы $G(V, E)$, $G'(V', E')$, отображение $f_0 : V \to T$}
	\KwOut{измененённое отображение $f_N$}
	\Begin(CCE){
		$K := 0$
		
		\ForEach{$\mathcal{C}_0 \in \mathcal{K}_0$}{
				Пусть $(v_0^{\prime}, v_1^{\prime})$ -- первая дуга контура $\mathcal{C}_0$.
			
			 	$\mathcal{A} := \emptyset$
			 	
			 	$\mathcal{A}_0 := \emptyset$
			 
			 	\ForAll{$v_0: f_K(v_0) \ne \emptyset$}{
			 		$\mathcal{A}_0 := \mathcal{A}_0 \cup \{v_0\}$
			 		
			 		$\mathcal{A} := \mathcal{A} \cup \{(v_0, v_0, 0)\}$
		 		}
	 		
	 			\For{$s = 1, 2, ..., |\mathcal{C}_0|$}{
		 			Пусть $(q_0, q_1)$ -- $s$-я дуга контура $\mathcal{C}_0$.
		 			
	 				$\mathcal{B} := \emptyset$
	 				
	 				\ForEach{$(v, v_0, s - 1) \in \mathcal{A}$}{
	 					\For{$v^{\prime} \in \Gamma(v) $}{
	 						\If{$q_1 \in f_K(v^{\prime})$}{
	 							$\mathcal{B} := \mathcal{B} \cup \{(v^{\prime}, v_0, s)\}$
 							}
 						}
 					}
 				
	 				$\mathcal{A} := \mathcal{B}$
	 			}
	 			
	 			
	 			\ForEach{$v_0 \in \mathcal{A}_0$}{
	 				\If{$ (v_0, v_0, |\mathcal{C}_0|) \notin \mathcal{A} $}{
	 					$S := K$
	 					
	 					\For{$v' \in f_S(v_0)$}{
	 						$f_{K+1} := Exclude(f_{K}, v_0, v')$
	 						
	 						$K := K + 1$
	 					}
 					}
	 			}
		}
		\Return{$f_N$}
	}

	\caption{Алгоритм проверки контуров}
	\label{alg:CCE}
\end{algorithm}

Нахождение всех контуров графа и такой их обход -- задачи с очень высокой вычислительной сложностью, но на практически встречающихся графах, тем не менее, основная работа будет сделана алгоритмом $LCCE$. Впрочем, можно даже рассматривать не все циклы -- можно попытаться выделить подграф совпадения и по неточному списку кандидатов. Здесь много зависит от конкретного вида графов и стоящей перед нами задачи.

Авторы статьи \cite{patmat} ожидают, что граф-паттерн будет содержать достаточно мало циклов, поэтому приводимая ими оценка сложности $O(|\mathcal{K}_0|n_t(|V| + |E|))$, где $n_t = \max\limits_{\mathcal{C}_0 \in \mathcal{K}_0} n_{\mathcal{C}_0}$, где $n_{\mathcal{C}_0}$ -- это количество вершин в $V$, соответствующих контуру $\mathcal{C}_0$, является удовлетворительной.

\subsection{Общий алгоритм исключения вершин-кандидатов}

Два вышеприведённых алгоритма объединяются в следующем цикле, который выполняется до тех пор, пока из отображения $f$ ещё удаляются какие-то вершины-кандидаты.

\begin{algorithm}
	\Large
	\KwIn{графы $G(V, E)$, $G'(V', E')$, отображение $f_0 : V \to T$}
	\KwOut{измененённое отображение $f_N$}
	\Begin(Exclusion){
		$K := 0$
		
		\While{$K = 0$ или $f_K \ne f_{K - 2}$}{
			$f_{K+1} := LCCE(G, G', f_{K})$
			
			$f_{K+2} := CCE(G, G', f_{K+1})$
			
			$K := K + 2$
		}
		\Return{$f_K$}
	}

	\caption{Алгоритм исключения вершин-кандидатов}
	\label{alg:EE}
\end{algorithm}

Формируя начальное отображение $f$ исходя из совпадений по меткам архивного графа и графа-паттерна, мы передаём его алгоритму Exclusion и получаем на выходе новое отображение, состоящее исключительно из истинных кандидатов.
